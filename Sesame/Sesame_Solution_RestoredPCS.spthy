/*
 *  Authors: Charlie Jacomme, Aurora Naska
 *  Model Name: sesame.spthy
 *  Status: FINISHED
 *

$ tamarin-prover --prove Sesame_Solution_RestoredPCS.spthy 

==============================================================================
summary of summaries:

analyzed: Sesame_Solution_RestoredPCS.spthy

  can_create_user (exists-trace): verified (5 steps)
  can_key_exchange (exists-trace): verified (4 steps)
  can_receive_sym_message (exists-trace): verified (8 steps)
  can_receive_attacker (exists-trace): verified (8 steps)
  can_ratchet_attacker (exists-trace): verified (7 steps)
  SameRootKey (all-traces): verified (18 steps)
  stGlobalSendingChainKey (all-traces): verified (39 steps)
  stReceiverChainKey (all-traces): verified (25 steps)
  GlobalSendChainPreceededByStartChain (all-traces): verified (40 steps)
  ReceiveChainPreceededByStartChain (all-traces): verified (26 steps)
  StartChainAtom (all-traces): verified (4 steps)
  OriginSendingChainKey (all-traces): verified (77 steps)
  OriginReceivingChainKey (all-traces): verified (28 steps)
  SameChainKeysMeansSameRootKey (all-traces): verified (230 steps)
  SameSendingChainMeansSameRootKey (all-traces): verified (54 steps)
  SameReceiveChainMeansSameRootKey (all-traces): verified (54 steps)
  NoSessionWithSelf (all-traces): verified (19 steps)
  NoDoubleRole (all-traces): verified (344 steps)
  NoDoubleRoleSt1 (all-traces): verified (34 steps)
  NoDoubleRoleSt2 (all-traces): verified (44 steps)
  SameChainKeysMeansSameRootKeyBis (all-traces): verified (618 steps)
  SameSendingChainMeansSameRootKeyBis2 (all-traces): verified (26 steps)
  SameReceiveChainMeansSameRootKeyBis (all-traces): verified (330 steps)
  SameSendingChainMeansSameRootKeyBis3 (all-traces): verified (54 steps)
  MonotonousAfterSend (all-traces): verified (38 steps)
  AsymmetricNeedsCompromiseBefore (all-traces): verified (1995 steps)
  ForwardSecrecySender (all-traces): verified (12 steps)
  rkImpo (all-traces): verified (734 steps)
  rkImpoBis (all-traces): verified (228 steps)
  PCSrk (all-traces): verified (1234 steps)
  PCS (all-traces): verified (9 steps)
  SameRootKeyForTid (all-traces): verified (18 steps)
  StartPrev (all-traces): verified (78 steps)
  distinct_tid (all-traces): verified (53 steps)
  SamePartner (all-traces): verified (44 steps)
  PCS_Conversation (all-traces): verified (146 steps)

==============================================================================

270.93s user 
87.19s system 
335% cpu 
1:46.83 total

*/

theory sesame
begin

heuristic: o "oracle.py"
functions: kdf/2
builtins: hashing, symmetric-encryption, signing

/****************************************************************************************************
*
*                                                 RESTRICTIONS
*
****************************************************************************************************/

/* We restrict that the attacker can compromise a root key only once, since every other key in the chain can be computed by hashing forward.
  The restriction removes looping behaviours.
*/
restriction CompromiseOnceSending:
"
All A B rk #i #j. CompromiseSending(A, B, rk)@i & CompromiseSending(A, B, rk)@j ==> #i=#j 
"

restriction CompromiseOnceReceiving:
"
All A B rk #i #j. CompromiseReceiving(A, B, rk)@i & CompromiseReceiving(A, B, rk)@j ==> #i=#j 
"

/* Restrict that an asymmetric step can be performed once, since responder is a persistent fact and one can skip messages.
*/
restriction SingleAsymmetricStep:
"
All B A rk new_rk #i #j. AsymetricStepB(B, A, rk, new_rk)@i & AsymetricStepB(B, A, rk, new_rk)@j ==> #i = #j
"

restriction SingleAsymmetricStepBis:
"
All B A rk new_rk new_rk2 #i #j. AsymetricStepB(B, A, rk, new_rk)@i & AttackerAsymetricStep(B, A, rk, new_rk2)@j ==> F
"

// Restrictions on receive once and skip once. The receiver can only skip or receive a message once.
restriction SingleReceive:
"
All B A rck#i #j. ReceiveOnce(B, A, rck)@i & ReceiveOnce(B, A, rck)@j ==> #i = #j
"

restriction SingleSkip:
"
All B A rck#i #j. SkipOnce(B, A, rck)@i & SkipOnce(B, A, rck)@j ==> #i = #j
"

restriction SingleDevice:
"
All id s1 s2 #i #j. CreateDevice(id, s1)@i &   CreateDevice(id, s2)@j ==> #i = #j
"

// Cannot start session with self.
restriction NotStartSessionWithSelf:
"
All A B #i. AssociateDevice(A, B)@i ==> not(A=B)
"
// We comment out the restriction to enable multiple session/model Sesame
/*
restriction SingleSessionWithSmbd:
"
All A B #i #j. AssociateDevice(A, B)@i &  AssociateDevice(A, B)@j  ==> #i = #j
"
*/

restriction old_session_expiration:
" All tidA1 tidA2 A B rk1 rk2 #i #j.
 InitSessionKeyExchange(tidA1, A, B, rk1)@i &  InitSessionKeyExchange(tidA2, A, B, rk2)@j & i<j ==>
                              (All somerk somesck #k. GlobalSendChainKey(tidA1,A, B, somerk, somesck)@k & j<k ==> F)
                              & (All somerk #k.  StartChainRk(tidA1, A, B, somerk)@k & j<k ==> F) "


restriction old_session_expiration_bis:
" All tidA1 tidA2 A B rk1 rk2 rk3 #i #j #k. 
StartChainRk(tidA1, A, B, rk2)@i &  StartChainRk(tidA2, A, B, rk1)@j & StartChainRk(tidA1, A, B, rk3)@k & i < j & j < k ==> tidA2 =tidA1"



/****************************************************************************************************
*
*                                                  PROTOCOL
*
****************************************************************************************************/

/* Create a user device with an identity key
*/
rule CreateDevice[color= FDFCDC]:
    [ Fr(~sk)]
  --[ CreateDevice($id, ~sk) ]->
    [ !Partie($id, ~sk) ]



/*****************************************
*
* Inititalize
*
*****************************************/

/* Initialize the communication channel.
*/
rule Init[color= FBD1A2]:
    [ !Partie(A, skA),
      !Partie(B, skB)
       ]
  --[ AssociateDevice(A, B),
      AssociateDevice(B, A)  ]->
    [ UserState(A, B, skA, pk(skB)), 
      UserState(B, A, skB, pk(skA))
    ]

/* Initialize the key exchange of the two communicating parties: 
*  -- Choose a common root key
*  -- Create a sending chain key for A and a respective receiver chain key for B.
*/
rule InitKeyExchange[color= FBD1A2]:
    [ UserState(A, B, skA, pk(skB)), 
      UserState(B, A, skB, pk(skA)),
      Fr(~rk),
      Fr(~tidA),
      Fr(~tidB)
       ]
  --[ KeyExchange(A, B, ~rk),
      InitKeyExchange(A, B),      
      InitKeyExchange(B, A),  
      InitSessionKeyExchange(~tidA, A, B, ~rk),      
      InitSessionKeyExchange(~tidB, B, A, ~rk),   
      StartChainRk(~tidA,A, B, ~rk),
      StartChainRk(~tidB,B, A, ~rk),
      Heal(~tidA,A, ~rk), 
      Heal(~tidB,B, ~rk),      
      ConversationStartChainRk(A, B, ~rk),
      ConversationStartChainRk(B, A, ~rk),
      StartChainRkSnd(~tidA,A, B, ~rk),
      StartChainRkRcv(~tidB,B, A, ~rk)
]->
    [ SendingChainKey(~rk,~tidA, A, B, h(~rk)), 
      !ReceivingChainKey(~tidB,~rk, B, A, h(~rk)),
       BookKeppingRootKeys(~tidA, A, ~rk),
       BookKeppingRootKeys(~tidB, B , ~rk  ),
       BookKeppingGlobalRootKeys(~tidA, A, ~rk),
       BookKeppingGlobalRootKeys(~tidB, B , ~rk  )
    ]


/*****************************************
*
* Asymmetric Ratchet
*
*****************************************/  

/* In the asymmetric ratchet, A and B forward the root key, instead we derive a fresh root key to replace the old one. 
   In this step, the parties switch roles from sender to receiver and derive the new sending/receiving chain keys.
   We abstract to derive a new root key instead of ratcheting forward, therefore both parties are healed at the same time.
*/
rule SendReceiveAsymetric[color= 00b2ca]:
    [ SendingChainKey(~rk,~tidA, A, B, ck),
    !ReceivingChainKey(~tidB,~rk, B, A, ck),
    BookKeppingRootKeys(~tidA, A, ~rk  ),
    BookKeppingRootKeys(~tidB, B, ~rk),
    BookKeppingGlobalRootKeys(~tidA, A, ~rk  ),
    BookKeppingGlobalRootKeys(~tidB, B, ~rk),
     Fr(~new_rk)
    ]
  --[ AsymetricStep(A, B, ck, ~new_rk),
      AsymetricStepB(B, A, ~rk, ~new_rk) ,
      Heal(~tidA,A, ~rk), 
      Heal(~tidB,B, ~rk),
      ConversationHeal(A, B, ~rk),
      ConversationHeal(B, A, ~rk),
      KeyUpdate(~rk, ~new_rk),
      StartChainRk(~tidA,A, B, ~new_rk),
      StartChainRk(~tidB,B, A, ~new_rk),
      ConversationStartChainRk(A, B, ~new_rk),
      ConversationStartChainRk(B, A, ~new_rk),
      StartChainRkRcv(~tidA,A, B, ~new_rk),
      StartChainRkSnd(~tidB,B, A, ~new_rk),      
      ]->
    [ SendingChainKey(~new_rk,~tidB, B, A, h(~new_rk)),
      !ReceivingChainKey(~tidA,~new_rk, A, B, h(~new_rk)),
      BookKeppingRootKeys(~tidA, A, ~new_rk),
      BookKeppingRootKeys(~tidB, B , ~new_rk  ),
      BookKeppingGlobalRootKeys(~tidA, A, ~new_rk),
      BookKeppingGlobalRootKeys(~tidB, B , ~new_rk  )


    ]


/*****************************************
*
* Attacker Asymmetric Ratchet
*
*****************************************/  

/* After compromising one of the agents, the attacker should be able to trigger asymetric ratchets.
   SendReceiveAsymetric_ReceiveToSend - Attacker's partner goes from receiver to sender
   SendReceiveAsymetric_SendToReceive - attacker's partner goes from sender to receiver
   Attacker shows its knows the current chain key.
*/

//Attacker performs asymmetric step with receiver
rule SendReceiveAsymetric_ReceiveToSend[color= 00b2ca]:
    [ In(rck) ,
    !ReceivingChainKey(~tidB,~rk, B, A, rck),
     BookKeppingRootKeys(~tidB, B , ~rk  ),
     BookKeppingGlobalRootKeys(~tidB, B , ~rk  ),
     Fr(~new_rk)
    ]
  --[ AttackerAsymetricStep(B, A, ~rk, ~new_rk),
      KeyUpdate(~rk, ~new_rk),
      StartChainRk(~tidB,B, A, ~new_rk),
      ConversationStartChainRk(B, A, ~new_rk),
      StartChainRkSnd(~tidB,B, A, ~new_rk)      
      ]->
    [ SendingChainKey(~new_rk,~tidB, B, A, h(~new_rk)),
      BookKeppingRootKeys(~tidB,  B , ~new_rk  ),
      BookKeppingGlobalRootKeys(~tidB,  B , ~new_rk  ),
      Out(~new_rk)
    ]

//Attacker performs asymmetric step with sender
rule SendReceiveAsymetric_SendToReceive[color= 00b2ca]:
    [ SendingChainKey(~rk, ~tidA, A, B, sck),
     In(sck) ,
     BookKeppingRootKeys(~tidA, A, ~rk  ),
     BookKeppingGlobalRootKeys(~tidA, A, ~rk  ),
     Fr(~new_rk)
    ]
  --[ AttackerAsymetricStep(A, B, ~rk, ~new_rk),
      StartChainRk(~tidA,A, B, ~new_rk),
      ConversationStartChainRk(A, B, ~new_rk),
      StartChainRkRcv(~tidA,A, B, ~new_rk),      
      KeyUpdate(~rk, ~new_rk) 
      ]->
    [ Out(~new_rk),
     BookKeppingRootKeys(~tidA, A, ~new_rk  )  ,  
     BookKeppingGlobalRootKeys(~tidA, A, ~new_rk  )  ,  
     !ReceivingChainKey(~tidA,~new_rk, A, B, h(~new_rk))
    ]

/*****************************************
*
* Symmetric Ratchet
*
*****************************************/

/* The sender ecrypt a fresh message and forwards the chain key.
*/
rule SendSymetric[color= 7DCFB6]:
    [ SendingChainKey(~rk, ~tidA, A, B, sck),
     BookKeppingGlobalRootKeys(~tidA, A, ~rk  ),
     Fr(~payload)
    ]
  --[ SendMessage(A, B, ~rk, sck, ~payload),
      SendPayload(A, B, ~rk, ~payload),
      SendChainKey(A, B, ~rk, sck),
      GlobalSendChainKey(~tidA,A, B, ~rk, sck)
    ]->
    [ Out(senc(~payload, sck)),
      SendingChainKey(~rk, ~tidA, A, B, h(sck)),
       BookKeppingGlobalRootKeys(~tidA, A, ~rk  )
    ]


/*  Receiver receive a message and forwards the receiving chain key.
*/
rule ReceiveSymetric[color= F79256]:
    [ !ReceivingChainKey(~tidB,~rk, B, A, rck),
      In(senc(payload, rck))
    ]
  --[ ReceivedMessage(B, A, ~rk, rck, payload),
      ReceiveOnce(B, A, rck),
      ReceiverChain(~tidB,B, A, ~rk, rck)  ]-> 
    [!ReceivingChainKey(~tidB,~rk, B, A, h(rck))
    ]
    

/*  Receiver skips a message and forwards the receiving chain key.
*/
rule ReceiveSymetricSkip[color= F79256]:
    [ !ReceivingChainKey(~tidB,~rk, B, A, rck),
      In(senc(payload, rck))
    ]
  --[ NotReceivedMessage(B, A, ~rk, rck, payload),
      SkipOnce(B, A, rck),
      ReceiverChain(~tidB,B, A, ~rk, rck)
        ]-> 
    [!ReceivingChainKey(~tidB,~rk, B, A, h(rck))
    ]
    
    
/*****************************************
*
* Attacker Compromise
*
*****************************************/ 

/* The attacker compromises the state of one of the parties, and learn the session's root key rk and sending/receiving chain key sck/rck.
   Root key rk is kept in the state only for bookkeeping, we do not consider it to be part of the state as the normal rk in the DR. 
   The reason for that is that the rk, in the real DR is derived from the old one, and we abstract by creating a fresh rk on every ratchet. 
*/

// Attacker compromises the sender and learn the current rk and sending chain key sck
rule CompromiseSender[color= ea3546]:
    [ SendingChainKey(~rk, ~tidA, A, B, h(sck)),
     BookKeppingGlobalRootKeys(~tidA, A, ~rk  ) ]
  --[ 
      CompromiseSending(A, B, ~rk),
      CompromiseChain(A, B, h(sck)),
      CompromisePartie(A, B),
      CompromisePartieThread(~tidA, A, B),
      GlobalSendChainKey(~tidA,A, B, ~rk, h(sck))
    ]->
    [ SendingChainKey(~rk, ~tidA, A, B, h(sck)),
     BookKeppingGlobalRootKeys(~tidA, A, ~rk  ),
       Out(h(sck)) ]


// Attacker compromises the receiver and learn the a rk and receiving chain key rck
rule CompromiseReceiving[color= ea3546]:
    [ !ReceivingChainKey(~tidB,~other_rk, A, B, h(rck))]
  --[ 
      CompromiseReceiving(A, B, ~other_rk),
      CompromiseChain(A, B, h(rck)),
      CompromisePartieThread(~tidB, A, B),
      CompromisePartie(A, B)
 ]->
    [ Out(h(rck)) ]

/****************************************************************************************************
*
*                                                   LEMMA
*
****************************************************************************************************/

// BEGIN SANITY LEMMA
lemma can_create_user: exists-trace
  "Ex A B  #i.
  AssociateDevice(A, B) @ i"

lemma can_key_exchange: exists-trace
  "Ex A B rk #i.
  KeyExchange(A, B, rk) @ i"

lemma can_receive_sym_message: exists-trace
  "Ex A B rk rck payload #i.
  ReceivedMessage(A, B, rk, rck, payload) @ i"

lemma can_receive_attacker: exists-trace
  "Ex A B rk rck payload #i #j.
  ReceivedMessage(A, B, rk, rck, payload) @ i
  & KU(payload)@j"

lemma can_ratchet_attacker: exists-trace
  "Ex A B rk rkother #i.
  AttackerAsymetricStep(A, B, rk, rkother) @ i"



/***************************************

        Loop breakers

***************************************/

lemma SameRootKey[reuse, use_induction]:
"
All A B rk tid #i #j. StartChainRk(tid, A, B, rk)@i & StartChainRk(tid, A, B, rk) @j
==> #i=#j
"

lemma stGlobalSendingChainKey[reuse, use_induction]:
"
All A B rk sck tid #i. GlobalSendChainKey(tid,A, B, rk, sck)@i
==> rk << sck
"

lemma stReceiverChainKey[reuse, use_induction]:
"
All A B rk sck tid #i. ReceiverChain(tid,A, B, rk, sck)@i
==> rk << sck
"

lemma GlobalSendChainPreceededByStartChain[reuse, use_induction]:
"
All A B rk sck tid #i. GlobalSendChainKey(tid,A, B, rk, sck)@i
==> Ex #j. StartChainRk(tid, A, B, rk) @j & j<i 
"

 lemma ReceiveChainPreceededByStartChain[reuse, use_induction]:
"
All A B rk sck tid #i. ReceiverChain(tid,A, B, rk, sck)@i
==> Ex #j. StartChainRk(tid,A, B, rk) @j & j<i 
"

lemma StartChainAtom[reuse, use_induction]:
"
All A B rk tid #j. StartChainRk(tid,A, B, h(rk))@j ==> F
"

lemma OriginSendingChainKey[reuse, use_induction, hide_lemma=GlobalSendChainPreceededByStartChain,hide_lemma=ReceiveChainPreceededByStartChain]:
"
All A B rk sck tid #i. GlobalSendChainKey(tid,A, B, rk, sck)@i
==> 
 (sck=h(rk))
| Ex pck #j. sck=h(pck) &  GlobalSendChainKey(tid,A, B, rk, pck)@j & j<i 
"

 lemma OriginReceivingChainKey[reuse, use_induction, hide_lemma=GlobalSendChainPreceededByStartChain,hide_lemma=ReceiveChainPreceededByStartChain]:
"
All A B rk sck tid #i. ReceiverChain(tid,A, B, rk, sck)@i
==>
 (sck=h(rk))
| Ex pck #j. sck=h(pck) &  ReceiverChain(tid,A, B, rk, pck)@j & j<i "
 

lemma SameChainKeysMeansSameRootKey[reuse, use_induction]:
"
All A B rk rk2 sck tid tid2 #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & ReceiverChain(tid2,B, A, rk2, sck)@j
==> rk=rk2 
"

lemma SameSendingChainMeansSameRootKey[reuse, use_induction]:
"
All A B rk rk2 sck tid tid2 #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & GlobalSendChainKey(tid2,B, A, rk2, sck)@j
==> rk=rk2
"

lemma SameReceiveChainMeansSameRootKey[reuse, use_induction]:
"
All A B rk rk2 sck tid tid2 #i #j. ReceiverChain(tid,A, B, rk, sck)@i & ReceiverChain(tid2,B, A, rk2, sck)@j
==> rk=rk2
"

lemma NoSessionWithSelf[reuse, use_induction]:
"
(All A rk sck tid #i. GlobalSendChainKey(tid,A, A, rk, sck)@i
==> F)
&
(All A rk sck tid #i. ReceiverChain(tid,A, A, rk, sck)@i
==> F)
&
(All A rk tid #i.  StartChainRk(tid,A, A, rk)@i
==> F)
"

lemma NoDoubleRole[reuse, use_induction,hide_lemma=GlobalSendChainPreceededByStartChain,hide_lemma=ReceiveChainPreceededByStartChain, hide_lemma=OriginSendingChainKey, hide_lemma=OriginReceivingChainKey]:
"
All A B rk rk2 tid tid2 sck #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & ReceiverChain(tid2,A, B, rk2, sck)@j
==> F
"

lemma NoDoubleRoleSt1[reuse, use_induction,hide_lemma=GlobalSendChainPreceededByStartChain,hide_lemma=ReceiveChainPreceededByStartChain, hide_lemma=OriginSendingChainKey, hide_lemma=OriginReceivingChainKey]:
"
All A B rk tid tid2 sck #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i &  StartChainRkRcv(tid2,A, B, rk)@j
==> F
"

lemma NoDoubleRoleSt2[reuse, use_induction,hide_lemma=GlobalSendChainPreceededByStartChain,hide_lemma=ReceiveChainPreceededByStartChain, hide_lemma=OriginSendingChainKey, hide_lemma=OriginReceivingChainKey]:
"
All A B rk tid tid2 sck #i #j.  StartChainRkSnd(tid,A, B, rk)@i & ReceiverChain(tid2,A, B, rk, sck)@j
==> F
"

lemma SameChainKeysMeansSameRootKeyBis[reuse, use_induction]:
"
All A B A2 B2 rk rk2 sck tid tid2 #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & ReceiverChain(tid2,B2, A2, rk2, sck)@j
==> rk=rk2 & B=B2 & A=A2
"

lemma SameSendingChainMeansSameRootKeyBis2[reuse, use_induction]:
"
All A B A2 B2 rk rk2 sck  tid  #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & GlobalSendChainKey(tid,A2, B2, rk2, sck)@j
==> rk=rk2 & B=B2 & A=A2 
"

lemma SameReceiveChainMeansSameRootKeyBis[reuse, use_induction]:
"
All A B A2 B2 rk rk2 sck tid tid2 #i #j. ReceiverChain(tid,A, B, rk, sck)@i & ReceiverChain(tid2,A2, B2, rk2, sck)@j
==> rk=rk2 & B=B2 & A=A2  
"

lemma SameSendingChainMeansSameRootKeyBis3[reuse, use_induction]:
"
All A B A2 B2 rk  rk2 sck  tid tid2 #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & GlobalSendChainKey(tid2,A2, B2, rk2, sck)@j
==>  tid=tid2
"

lemma MonotonousAfterSend[reuse, use_induction, hide_lemma=OriginSendingChainKey,hide_lemma=OriginReceivingChainKey]:
"
All A B rk sck sck2 tid #i #j. GlobalSendChainKey(tid,A, B, rk, sck)@i & SendChainKey(A, B, rk, sck2)[+]@j & j < i ==> sck2 << sck 
"

lemma AsymmetricNeedsCompromiseBefore[reuse, use_induction]:
"
(All A B rk sck #i. AttackerAsymetricStep(A, B, rk, sck)@i
==> (Ex  #k. CompromisePartie(A, B)@k & k < i)
   | (Ex #k. CompromisePartie(B, A)@k & k < i ) 
)
&
(All A B rk sck #i #j. SendChainKey(A, B, rk, sck)@i & KU(sck)@j
==> (Ex  #k. CompromisePartie(A, B)@k & k < i) 
   | (Ex #k. CompromisePartie(B, A)@k & k < j) 
)
&
(All A B rk sck tid #i #j. ReceiverChain(tid,A, B, rk, sck)@i & KU(sck)@j
==> 
    (Ex  #k. CompromisePartie(A,B)@k & k<j ) 
  |  (Ex  #k. CompromisePartie(B, A)@k & k<j ) 
   
)
"

lemma ForwardSecrecySender[reuse, use_induction]:
"
(All A B rk sck #i #j. SendChainKey(A, B, rk, sck)@i & KU(sck)@j
==> (Ex  #k. CompromisePartie(A, B)@k & k < i) 
   | (Ex #k. CompromisePartie(B, A)@k ) 
)
"


// This is false in Sesame
/*
lemma singleInitKE[reuse]:
"
All A B #i #j. InitKeyExchange(A,B)@j & InitKeyExchange(A,B)@i
==> #i=#j
"
*/

lemma rkImpo[reuse, use_induction]:
"
All A B rk rk2 rk3 tid #i #j #l. StartChainRk(tid,A, B, rk)@i &  StartChainRk(tid,A, B, rk3)@l & KeyUpdate(rk,rk3)@l & i < l    &     StartChainRk(tid,A, B, rk2)@j  
==>    ( #i=#j |   j< i | l < j   | #j = #l)
"

lemma rkImpoBis[reuse, use_induction]:
"
All A B rk rk2 rk3 sck tid #i #j #l. StartChainRk(tid,A, B, rk)@i &  StartChainRk(tid,A, B, rk3)@l  & i < l    &  GlobalSendChainKey(tid,A, B, rk2, sck )@j & l<j
==>   not(rk=rk2) 
"

lemma PCSrk[reuse, use_induction, hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B rk rk2 tid tid2 #i #j #l. StartChainRk(tid,A, B, rk )@i & KU(rk)@j & Heal(tid2,B,rk2)@l & Heal(tid,A,rk2)@l & (l < i | #l=#i)
==> (Ex  #k. CompromisePartie(A, B)@k & l < k  )
   | (Ex #k. CompromisePartie(B, A)@k & l < k   ) 
)
&
// in the second case #l=#i is not used since it is not possible
(All A B rk sck rk2 tid tid2 #i #j #l. GlobalSendChainKey(tid,A, B, rk, sck )@i & KU(sck)@j & Heal(tid2,B,rk2)@l & Heal(tid,A,rk2)@l & (l < i | #l=#i)
==> (Ex  #k. CompromisePartie(A, B)@k & l < k  )
   | (Ex #k. CompromisePartie(B, A)@k & l < k   ) 
)
&
(All A B rk rk2 sck tid tid2 #i #j #l #r. ReceiverChain(tid,A, B, rk, sck)@i & KU(sck)@j & Heal(tid2,B,rk2)@l & Heal(tid,A,rk2)@l & StartChainRk(tid,A,B,rk)@r & (l < r | #l = #r)
==> 
    (Ex  #k. CompromisePartie(A,B)@k & l<k ) 
  |  (Ex  #k. CompromisePartie(B, A)@k & l<k )   
)"
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( (∃ A B rk rk2 tid tid2 #i #j #l.
           (StartChainRk( tid, A, B, rk ) @ #i) ∧
           (!KU( rk ) @ #j) ∧
           (Heal( tid2, B, rk2 ) @ #l) ∧
           (Heal( tid, A, rk2 ) @ #l)
          ∧
           (((#l < #i) ∨ (#l = #i))) ∧
           (∀ #k. (CompromisePartie( A, B ) @ #k) ⇒ ¬(#l < #k)) ∧
           (∀ #k. (CompromisePartie( B, A ) @ #k) ⇒ ¬(#l < #k)))  ∥
         (∃ A B rk sck rk2 tid tid2 #i #j #l.
           (GlobalSendChainKey( tid, A, B, rk, sck ) @ #i) ∧
           (!KU( sck ) @ #j) ∧
           (Heal( tid2, B, rk2 ) @ #l) ∧
           (Heal( tid, A, rk2 ) @ #l)
          ∧
           (((#l < #i) ∨ (#l = #i))) ∧
           (∀ #k. (CompromisePartie( A, B ) @ #k) ⇒ ¬(#l < #k)) ∧
           (∀ #k. (CompromisePartie( B, A ) @ #k) ⇒ ¬(#l < #k)))  ∥
         (∃ A B rk rk2 sck tid tid2 #i #j #l #r.
           (ReceiverChain( tid, A, B, rk, sck ) @ #i) ∧
           (!KU( sck ) @ #j) ∧
           (Heal( tid2, B, rk2 ) @ #l) ∧
           (Heal( tid, A, rk2 ) @ #l) ∧
           (StartChainRk( tid, A, B, rk ) @ #r)
          ∧
           (((#l < #r) ∨ (#l = #r))) ∧
           (∀ #k. (CompromisePartie( A, B ) @ #k) ⇒ ¬(#l < #k)) ∧
           (∀ #k. (CompromisePartie( B, A ) @ #k) ⇒ ¬(#l < #k))) )
    case case_1
    solve( StartChainRk( tid, A, B, rk ) @ #i )
      case InitKeyExchange_case_1
      solve( Heal( tid2, B, rk2 ) @ #l )
        case InitKeyExchange_case_1
        by solve( !KU( ~rk ) @ #j )
      next
        case InitKeyExchange_case_2
        by solve( !KU( ~rk ) @ #j )
      next
        case SendReceiveAsymetric_case_1
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      next
        case SendReceiveAsymetric_case_2
        by solve( !KU( ~rk ) @ #j )
      qed
    next
      case InitKeyExchange_case_2
      by solve( !KU( ~rk ) @ #j )
    next
      case SendReceiveAsymetric_ReceiveToSend
      solve( Heal( tid2, B, rk2 ) @ #l )
        case InitKeyExchange_case_1
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          solve( !ReceivingChainKey( ~tidB, ~rk, A, B, rck ) ▶₁ #i )
            case InitKeyExchange_case_1
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction /* from formulas */
                next
                  case InitKeyExchange_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_2
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction /* from formulas */
                next
                  case InitKeyExchange_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_3
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction /* from formulas */
                next
                  case InitKeyExchange_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_4
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction /* from formulas */
                next
                  case InitKeyExchange_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case ReceiveSymetric
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              by contradiction /* from formulas */
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* cyclic */
              qed
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction /* cyclic */
              next
                case SendSymetric
                solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #j)  ∥ (#j < #l) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            qed
          next
            case ReceiveSymetricSkip
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* cyclic */
              qed
            next
              case CompromiseReceiving_case_2
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction /* cyclic */
              next
                case SendSymetric
                solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #j)  ∥ (#j < #l) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_case_1
                  by contradiction /* from formulas */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      next
        case InitKeyExchange_case_2
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          solve( !ReceivingChainKey( ~tidA, ~rk, A, B, rck ) ▶₁ #i )
            case ReceiveSymetric
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              by contradiction /* from formulas */
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* cyclic */
              qed
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction /* cyclic */
              next
                case SendSymetric
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #j)  ∥ (#j < #l) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            qed
          next
            case ReceiveSymetricSkip
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* cyclic */
              qed
            next
              case CompromiseReceiving_case_2
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction /* cyclic */
              next
                case SendSymetric
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #j)  ∥ (#j < #l) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_case_1
                  by contradiction /* from formulas */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#vr < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#vr < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* from formulas */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      next
        case SendReceiveAsymetric_case_1
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          solve( !ReceivingChainKey( ~tidB, ~rk, A, B, rck ) ▶₁ #i )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case InitKeyExchange_case_3
            by contradiction
          next
            case InitKeyExchange_case_4
            by contradiction
          next
            case ReceiveSymetric
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              by contradiction
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                case InitKeyExchange_case_1
                by contradiction
              next
                case InitKeyExchange_case_2
                by contradiction
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction
              next
                case SendReceiveAsymetric_case_1
                by contradiction
              next
                case SendReceiveAsymetric_case_2
                by contradiction
              qed
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction
              next
                case SendSymetric
                solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#j = #l)  ∥ (#l < #j) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case ReceiveSymetricSkip
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                case InitKeyExchange_case_1
                by contradiction
              next
                case InitKeyExchange_case_2
                by contradiction
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction
              next
                case SendReceiveAsymetric_case_1
                by contradiction
              next
                case SendReceiveAsymetric_case_2
                by contradiction
              qed
            next
              case CompromiseReceiving_case_2
              by contradiction
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction
              next
                case SendSymetric
                solve( StartChainRk( ~tidB, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#j = #l)  ∥ (#l < #j) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #vr) ∨ (#vr < #l))) ∧ (¬(#l = #vr)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #vr)  ∥ (#vr < #l) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          qed
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          solve( !ReceivingChainKey( ~tidA, ~rk, A, B, rck ) ▶₁ #i )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case InitKeyExchange_case_3
            by contradiction
          next
            case InitKeyExchange_case_4
            by contradiction
          next
            case ReceiveSymetric
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              by contradiction
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange_case_1
                by contradiction
              next
                case InitKeyExchange_case_2
                by contradiction
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction
              next
                case SendReceiveAsymetric_case_1
                by contradiction
              next
                case SendReceiveAsymetric_case_2
                by contradiction
              qed
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction
              next
                case SendSymetric
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#j = #l)  ∥ (#l < #j) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case ReceiveSymetricSkip
            solve( !KU( h(rck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange_case_1
                by contradiction
              next
                case InitKeyExchange_case_2
                by contradiction
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction
              next
                case SendReceiveAsymetric_case_1
                by contradiction
              next
                case SendReceiveAsymetric_case_2
                by contradiction
              qed
            next
              case CompromiseReceiving_case_2
              by contradiction
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(rck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction
              next
                case SendSymetric
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#j = #l)  ∥ (#l < #j) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( ((((#l = #vr) ∨ (#vr < #l))) ∧ (¬(#l = #vr)))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                solve( (#l = #vr)  ∥ (#vr < #l) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by contradiction
              next
                case case_3
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                solve( StartChainRk( ~tidA.1, A.1, B.1, ~rk ) @ #j )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          qed
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      qed
    next
      case SendReceiveAsymetric_SendToReceive
      solve( Heal( tid2, B, rk2 ) @ #l )
        case InitKeyExchange_case_1
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          solve( SendingChainKey( ~rk, ~tidA, A, B, sck ) ▶₀ #i )
            case CompromiseSender
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_1
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.2 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_2
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.2 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_3
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.2 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_4
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.2 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_5
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#vr.1 < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#vr.1 < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_6
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_7
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_8
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendSymetric
            solve( !KU( h(sck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidB, B, A, ~rk ) @ #j.1 )
                case InitKeyExchange_case_1
                by contradiction /* from formulas */
              next
                case InitKeyExchange_case_2
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_SendToReceive
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_case_1
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* from formulas */
              qed
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidB, B, A, ~rk ) @ #j.1 )
                case InitKeyExchange_case_1
                by contradiction /* from formulas */
              next
                case InitKeyExchange_case_2
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_SendToReceive
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_case_1
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* from formulas */
              qed
            next
              case CompromiseSender
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_ReceiveToSend
                solve( SendingChainKey( ~rk.3, ~tidA.2, A.1, B.1, h(sck)
                       ) ▶₀ #vr.1 )
                  case CompromiseSender
                  by contradiction /* cyclic */
                next
                  case SendSymetric
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_case_2
                solve( SendingChainKey( ~rk.3, ~tidA.3, A.1, B.1, h(sck)
                       ) ▶₀ #vr.1 )
                  case CompromiseSender
                  by contradiction /* cyclic */
                next
                  case SendSymetric
                  by contradiction /* cyclic */
                qed
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      next
        case InitKeyExchange_case_2
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          solve( SendingChainKey( ~rk, ~tidA, A, B, sck ) ▶₀ #i )
            case CompromiseSender
            by contradiction /* from formulas */
          next
            case InitKeyExchange_case_1
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_2
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_3
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case InitKeyExchange_case_4
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.1 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( $id.1, $id ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( $id, $id.1 ) @ #k)
                      ∧
                       (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#vr < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#vr < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_1
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#vr.1 < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#vr.1 < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_2
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_3
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_4
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction /* contradictory subterm store */
              next
                case SubtermSplit2
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SendSymetric
            solve( !KU( h(sck) ) @ #vk )
              case CompromiseReceiving_case_1
              solve( StartChainRk( ~tidB.1, B, A, ~rk ) @ #j.1 )
                case InitKeyExchange_case_1
                by contradiction /* from formulas */
              next
                case InitKeyExchange_case_2
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* from formulas */
              next
                case SendReceiveAsymetric_SendToReceive
                solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                  case case_1
                  by solve( StartChainRk( ~tidA, A, B, ~rk ) @ #l )
                next
                  case case_2
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                    case SendReceiveAsymetric_SendToReceive
                    by contradiction /* cyclic */
                  qed
                qed
              next
                case SendReceiveAsymetric_case_1
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* from formulas */
              qed
            next
              case CompromiseReceiving_case_2
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case InitKeyExchange
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_SendToReceive
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_1
                by contradiction /* cyclic */
              next
                case SendReceiveAsymetric_case_2
                by contradiction /* cyclic */
              qed
            next
              case CompromiseSender
              solve( SendingChainKey( ~rk.2, ~tidA.1, A.1, B.1, h(sck)
                     ) ▶₀ #vr.1 )
                case CompromiseSender
                by contradiction /* cyclic */
              next
                case SendSymetric
                by contradiction /* cyclic */
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      next
        case SendReceiveAsymetric_case_1
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          solve( SendingChainKey( ~rk, ~tidA, A, B, sck ) ▶₀ #i )
            case CompromiseSender
            by contradiction
          next
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case InitKeyExchange_case_3
            by contradiction
          next
            case InitKeyExchange_case_4
            by contradiction
          next
            case SendReceiveAsymetric
            solve( BookKeppingRootKeys( ~tidA, A, ~rk ) ▶₂ #i )
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              solve( !KU( ~new_rk ) @ #j )
                case SendReceiveAsymetric_SendToReceive
                solve( !KU( h(~rk) ) @ #vk )
                  case CompromiseReceiving
                  by contradiction
                next
                  case CompromiseSender
                  solve( ~rk.3 ⊏ h(~rk) )
                    case SubtermSplit1
                    by contradiction
                  next
                    case SubtermSplit2
                    by contradiction
                  qed
                next
                  case c_h
                  by solve( !KU( ~rk ) @ #vk.1 )
                qed
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_1
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend_case_3
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend_case_4
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              by contradiction
            next
              case c_h
              by contradiction
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_5
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                by contradiction
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_6
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.4 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                by contradiction
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_7
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                by contradiction
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend_case_8
            solve( !KU( h(~rk) ) @ #vk )
              case CompromiseSender
              solve( ~rk.3 ⊏ h(~rk) )
                case SubtermSplit1
                by contradiction
              next
                case SubtermSplit2
                by contradiction
              qed
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendSymetric
            solve( BookKeppingRootKeys( ~tidA, A, ~rk ) ▶₂ #i )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case InitKeyExchange_case_3
              by contradiction
            next
              case InitKeyExchange_case_4
              by contradiction
            next
              case InitKeyExchange_case_5
              by contradiction
            next
              case InitKeyExchange_case_6
              by contradiction
            next
              case InitKeyExchange_case_7
              by contradiction
            next
              case InitKeyExchange_case_8
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend_case_1
              solve( !KU( h(~rk.2) ) @ #vk.1 )
                case CompromiseReceiving
                solve( (#j = #l)  ∥ (#l < #j) )
                  case case_1
                  by solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                next
                  case case_2
                  solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                    case SendReceiveAsymetric_ReceiveToSend
                    by contradiction
                  qed
                qed
              next
                case CompromiseSender
                solve( ~rk.3 ⊏ h(~rk.2) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                    case SendReceiveAsymetric_ReceiveToSend
                    by contradiction
                  qed
                qed
              next
                case c_h
                by solve( !KU( ~rk.2 ) @ #vk.2 )
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_2
              solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_3
              solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_4
              solve( StartChainRk( ~tidA, $id, B, ~rk ) @ #j )
                case SendReceiveAsymetric_ReceiveToSend
                by contradiction
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_5
              solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j )
                case SendReceiveAsymetric_ReceiveToSend
                solve( (#vr.1 = #l)  ∥ (#l < #vr.1) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  solve( !KU( h(sck) ) @ #vk )
                    case CompromiseReceiving_case_1
                    by contradiction
                  next
                    case CompromiseReceiving_case_2
                    by contradiction
                  next
                    case CompromiseSender
                    solve( SendingChainKey( ~rk.4, ~tidA.2, A.1, B.1, h(sck)
                           ) ▶₀ #vr.2 )
                      case CompromiseSender
                      by contradiction
                    next
                      case SendSymetric
                      by contradiction
                    qed
                  next
                    case c_h
                    solve( (∃ #k.
                             (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                           (∃ #k.
                             (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                      case case_1
                      by contradiction
                    next
                      case case_2
                      by contradiction
                    qed
                  qed
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_6
              solve( !KU( h(sck) ) @ #vk )
                case CompromiseReceiving_case_1
                by contradiction
              next
                case CompromiseReceiving_case_2
                by contradiction
              next
                case CompromiseSender
                solve( SendingChainKey( ~rk.4, ~tidA.2, A.2, B.1, h(sck)
                       ) ▶₀ #vr.3 )
                  case CompromiseSender
                  by contradiction
                next
                  case SendSymetric
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_7
              solve( !KU( h(sck) ) @ #vk )
                case CompromiseReceiving_case_1
                by contradiction
              next
                case CompromiseReceiving_case_2
                by contradiction
              next
                case CompromiseSender
                solve( SendingChainKey( ~rk.3, ~tidA.2, A.2, B.1, h(sck)
                       ) ▶₀ #vr.3 )
                  case CompromiseSender
                  by contradiction
                next
                  case SendSymetric
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_8
              solve( !KU( h(sck) ) @ #vk )
                case CompromiseReceiving_case_1
                by contradiction
              next
                case CompromiseReceiving_case_2
                by contradiction
              next
                case CompromiseSender
                solve( SendingChainKey( ~rk.3, ~tidA.2, A.2, B.1, h(sck)
                       ) ▶₀ #vr.3 )
                  case CompromiseSender
                  by contradiction
                next
                  case SendSymetric
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_SendToReceive
              solve( !KU( ~new_rk ) @ #j.1 )
                case SendReceiveAsymetric_SendToReceive
                solve( !KU( h(sck) ) @ #vk )
                  case CompromiseReceiving_case_1
                  by contradiction
                next
                  case CompromiseReceiving_case_2
                  by contradiction
                next
                  case CompromiseSender
                  solve( SendingChainKey( ~rk.3, ~tidA.2, A.1, B.2, h(sck)
                         ) ▶₀ #vr.2 )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    by contradiction
                  qed
                next
                  case c_h
                  solve( (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                    case case_1
                    by contradiction
                  next
                    case case_2
                    by contradiction
                  qed
                qed
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( !KU( ~new_rk ) @ #j.1 )
                case SendReceiveAsymetric_SendToReceive
                solve( !KU( h(sck) ) @ #vk )
                  case CompromiseReceiving_case_1
                  by contradiction
                next
                  case CompromiseReceiving_case_2
                  by contradiction
                next
                  case CompromiseSender
                  solve( SendingChainKey( ~rk.3, ~tidA.2, A.1, B.2, h(sck)
                         ) ▶₀ #vr.2 )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    by contradiction
                  qed
                next
                  case c_h
                  solve( (#vr < #l)  ∥
                         (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                    case case_1
                    by contradiction
                  next
                    case case_2
                    by contradiction
                  next
                    case case_3
                    by contradiction
                  qed
                qed
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( !KU( h(sck) ) @ #vk )
                case CompromiseReceiving_case_1
                by contradiction
              next
                case CompromiseReceiving_case_2
                by contradiction
              next
                case CompromiseSender
                solve( SendingChainKey( ~rk.3, ~tidA.3, A.2, B.1, h(sck)
                       ) ▶₀ #vr.2 )
                  case CompromiseSender
                  by contradiction
                next
                  case SendSymetric
                  by contradiction
                qed
              next
                case c_h
                solve( (#vr < #l)  ∥
                       (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                next
                  case case_3
                  by contradiction
                qed
              qed
            qed
          qed
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          solve( !KU( ~new_rk ) @ #j )
            case SendReceiveAsymetric_SendToReceive
            solve( SendingChainKey( ~rk, ~tidA, A, B, sck ) ▶₀ #i )
              case CompromiseSender
              by contradiction
            next
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case InitKeyExchange_case_3
              by contradiction
            next
              case InitKeyExchange_case_4
              by contradiction
            next
              case SendReceiveAsymetric
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                solve( ~rk.3 ⊏ h(~rk) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  by contradiction
                qed
              next
                case c_h
                by solve( !KU( ~rk ) @ #vk.1 )
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_1
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend_case_3
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( !KU( ~rk ) @ #vk.2 )
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_4
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                by contradiction
              next
                case c_h
                by contradiction
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_5
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                solve( ~rk.4 ⊏ h(~rk) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_6
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                solve( ~rk.4 ⊏ h(~rk) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_7
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                solve( ~rk.3 ⊏ h(~rk) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend_case_8
              solve( !KU( h(~rk) ) @ #vk )
                case CompromiseSender
                solve( ~rk.3 ⊏ h(~rk) )
                  case SubtermSplit1
                  by contradiction
                next
                  case SubtermSplit2
                  by contradiction
                qed
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendSymetric
              solve( !KU( h(sck) ) @ #vk )
                case CompromiseReceiving_case_1
                solve( StartChainRk( ~tidB.1, B, A, ~rk ) @ #j.2 )
                  case InitKeyExchange_case_1
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                    case InitKeyExchange_case_1
                    by contradiction
                  next
                    case InitKeyExchange_case_2
                    by contradiction
                  qed
                next
                  case InitKeyExchange_case_2
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                    case InitKeyExchange_case_1
                    by contradiction
                  next
                    case InitKeyExchange_case_2
                    by contradiction
                  qed
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  solve( (#j.2 = #l)  ∥ (#l < #j.2) )
                    case case_1
                    by solve( StartChainRk( ~tidA, A, B, ~rk ) @ #l )
                  next
                    case case_2
                    solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                      case SendReceiveAsymetric_ReceiveToSend
                      by contradiction
                    qed
                  qed
                next
                  case SendReceiveAsymetric_SendToReceive
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                    case SendReceiveAsymetric_SendToReceive
                    by contradiction
                  qed
                next
                  case SendReceiveAsymetric_case_1
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                    case SendReceiveAsymetric_case_1
                    by contradiction
                  next
                    case SendReceiveAsymetric_case_2
                    by contradiction
                  qed
                next
                  case SendReceiveAsymetric_case_2
                  solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.2 )
                    case SendReceiveAsymetric_case_1
                    by contradiction
                  next
                    case SendReceiveAsymetric_case_2
                    by contradiction
                  qed
                qed
              next
                case CompromiseReceiving_case_2
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              next
                case CompromiseSender
                solve( StartChainRk( ~tidA, A, B, ~rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  solve( SendingChainKey( ~rk.3, ~tidA.1, A.1, B.1, h(sck)
                         ) ▶₀ #vr.1 )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    by contradiction
                  qed
                next
                  case SendReceiveAsymetric_SendToReceive
                  solve( BookKeppingRootKeys( ~tidA, A, ~rk ) ▶₂ #i )
                    case SendReceiveAsymetric_SendToReceive
                    solve( SendingChainKey( ~rk.3, ~tidA.1, A.1, B.1, h(sck)
                           ) ▶₀ #vr.1 )
                      case CompromiseSender
                      by contradiction
                    next
                      case SendSymetric
                      by contradiction
                    qed
                  qed
                next
                  case SendReceiveAsymetric_case_1
                  solve( SendingChainKey( ~rk.3, ~tidA.1, A.1, B.1, h(sck)
                         ) ▶₀ #vr.1 )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    by contradiction
                  qed
                next
                  case SendReceiveAsymetric_case_2
                  solve( SendingChainKey( ~rk.3, ~tidA.2, A.1, B.1, h(sck)
                         ) ▶₀ #vr.1 )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    by contradiction
                  qed
                qed
              next
                case c_h
                solve( (#vr < #l)  ∥
                       (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                next
                  case case_3
                  by contradiction
                qed
              qed
            qed
          qed
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      qed
    next
      case SendReceiveAsymetric_case_1
      solve( Heal( tid2, B, rk2 ) @ #l )
        case InitKeyExchange_case_1
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          by solve( !KU( ~new_rk ) @ #j )
        qed
      next
        case InitKeyExchange_case_2
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by solve( !KU( ~new_rk ) @ #j )
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      next
        case SendReceiveAsymetric_case_1
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          by solve( !KU( ~new_rk ) @ #j )
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( Heal( ~tidA, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by solve( !KU( ~new_rk ) @ #j )
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      qed
    next
      case SendReceiveAsymetric_case_2
      solve( Heal( tid2, B, rk2 ) @ #l )
        case InitKeyExchange_case_1
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          by solve( !KU( ~new_rk ) @ #j )
        qed
      next
        case InitKeyExchange_case_2
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case InitKeyExchange_case_1
          by solve( !KU( ~new_rk ) @ #j )
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      next
        case SendReceiveAsymetric_case_1
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          by solve( !KU( ~new_rk ) @ #j )
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( Heal( ~tidB, A, ~rk.1 ) @ #l )
          case SendReceiveAsymetric_case_1
          by solve( !KU( ~new_rk ) @ #j )
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      qed
    qed
  next
    case case_2
    solve( Heal( tid2, B, rk2 ) @ #l )
      case InitKeyExchange_case_1
      solve( Heal( tid, A, ~rk ) @ #l )
        case InitKeyExchange_case_1
        by contradiction /* from formulas */
      next
        case InitKeyExchange_case_2
        solve( (sck = h(rk.1))  ∥
               (∃ pck #j.
                 (sck = h(pck)) ∧
                 (GlobalSendChainKey( ~tidB, A, B, rk.1, pck ) @ #j)
                ∧
                 #j < #i) )
          case case_1
          solve( StartChainRk( ~tidB, A, B, rk.1 ) @ #j )
            case InitKeyExchange
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric_ReceiveToSend
            solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk, h(~new_rk)
                   ) @ #i )
              case CompromiseSender
              by contradiction /* from formulas */
            next
              case SendSymetric
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseSender
                by contradiction /* from formulas */
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric_case_1
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric_case_2
            solve( !KU( h(~new_rk) ) @ #j.1 )
              case CompromiseReceiving
              by contradiction /* from formulas */
            next
              case CompromiseSender
              by contradiction /* from formulas */
            next
              case c_h
              by solve( !KU( ~new_rk ) @ #vk )
            qed
          qed
        next
          case case_2
          solve( !KU( h(pck) ) @ #j.2 )
            case CompromiseReceiving_case_1
            solve( GlobalSendChainKey( ~tidB, A, B, ~other_rk, h(pck) ) @ #i )
              case CompromiseSender
              by contradiction /* from formulas */
            next
              case SendSymetric
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #l )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            qed
          next
            case CompromiseReceiving_case_2
            solve( GlobalSendChainKey( ~tidB, A, B, ~other_rk, h(pck) ) @ #i )
              case CompromiseSender
              by contradiction /* from formulas */
            next
              case SendSymetric
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #l )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              qed
            qed
          next
            case CompromiseSender
            by contradiction /* from formulas */
          next
            case c_h
            solve( (#l < #i)  ∥ (#l = #i) )
              case case_1
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_2
              by solve( GlobalSendChainKey( ~tidB, A, B, rk.1, h(pck) ) @ #i )
            qed
          qed
        qed
      qed
    next
      case InitKeyExchange_case_2
      solve( Heal( tid, A.1, ~rk ) @ #l )
        case InitKeyExchange_case_1
        solve( (#l < #i)  ∥ (#l = #i) )
          case case_1
          solve( (sck = h(rk.1))  ∥
                 (∃ pck #j.
                   (sck = h(pck)) ∧
                   (GlobalSendChainKey( ~tidA, A, B, rk.1, pck ) @ #j)
                  ∧
                   #j < #i) )
            case case_1
            solve( StartChainRk( ~tidA, A, B, rk.1 ) @ #j )
              case InitKeyExchange
              solve( !KU( h(~rk) ) @ #j.1 )
                case CompromiseReceiving_case_1
                by contradiction /* from formulas */
              next
                case CompromiseReceiving_case_2
                by contradiction /* from formulas */
              next
                case CompromiseReceiving_case_3
                by contradiction /* from formulas */
              next
                case CompromiseReceiving_case_4
                by contradiction /* from formulas */
              next
                case CompromiseSender
                by contradiction /* from formulas */
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case SendReceiveAsymetric_ReceiveToSend
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseSender
                by contradiction /* from formulas */
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case SendReceiveAsymetric_SendToReceive
              by contradiction /* from formulas */
            next
              case SendReceiveAsymetric_case_1
              by contradiction /* from formulas */
            next
              case SendReceiveAsymetric_case_2
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction /* from formulas */
              next
                case CompromiseSender
                by contradiction /* from formulas */
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case case_2
            solve( (#j = #l)  ∥ (#l < #j) )
              case case_1
              solve( StartChainRk( ~tidA, A, B, rk.1 ) @ #j )
                case InitKeyExchange
                solve( !KU( h(pck) ) @ #j.2 )
                  case CompromiseReceiving_case_1
                  by contradiction /* from formulas */
                next
                  case CompromiseReceiving_case_2
                  by contradiction /* from formulas */
                next
                  case CompromiseSender
                  by contradiction /* from formulas */
                next
                  case c_h
                  solve( (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              qed
            next
              case case_2
              solve( !KU( h(pck) ) @ #j.2 )
                case CompromiseReceiving_case_1
                solve( StartChainRk( ~tidA, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              next
                case CompromiseReceiving_case_2
                solve( StartChainRk( ~tidA, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction /* cyclic */
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction /* cyclic */
                qed
              next
                case CompromiseSender
                by contradiction /* from formulas */
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case case_2
          by solve( GlobalSendChainKey( ~tidA, A, B, rk.1, sck ) @ #i )
        qed
      next
        case InitKeyExchange_case_2
        by contradiction /* from formulas */
      qed
    next
      case SendReceiveAsymetric_case_1
      solve( Heal( tid, A, ~rk ) @ #l )
        case SendReceiveAsymetric_case_1
        by contradiction
      next
        case SendReceiveAsymetric_case_2
        solve( (sck = h(rk.1))  ∥
               (∃ pck #j.
                 (sck = h(pck)) ∧
                 (GlobalSendChainKey( ~tidB, A, B, rk.1, pck ) @ #j)
                ∧
                 #j < #i) )
          case case_1
          solve( StartChainRk( ~tidB, A, B, rk.1 ) @ #j )
            case InitKeyExchange_case_1
            solve( GlobalSendChainKey( ~tidB, A, B, ~rk, h(~rk) ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              by contradiction
            qed
          next
            case InitKeyExchange_case_2
            solve( GlobalSendChainKey( ~tidB, A, B, ~rk, h(~rk) ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              by contradiction
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend
            solve( !KU( h(~new_rk) ) @ #j.1 )
              case CompromiseSender
              solve( (#l = #i)  ∥ (#i < #l) )
                case case_1
                by solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk.1, h(~new_rk.1)
                          ) @ #i )
              next
                case case_2
                by contradiction
              qed
            next
              case c_h
              solve( (#l < #i)  ∥ (#l = #i) )
                case case_1
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              next
                case case_2
                by solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk.1, h(~new_rk.1)
                          ) @ #i )
              qed
            qed
          next
            case SendReceiveAsymetric_SendToReceive
            solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk, h(~new_rk)
                   ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( !KU( ~new_rk ) @ #vk.1 )
                  case SendReceiveAsymetric_SendToReceive
                  solve( (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                    case case_1
                    by contradiction
                  next
                    case case_2
                    by contradiction
                  qed
                qed
              qed
            qed
          next
            case SendReceiveAsymetric_case_1
            solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk, h(~new_rk)
                   ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( ((((#l = #j) ∨ (#j < #l))) ∧ (¬(#l = #j)))  ∥
                       (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by solve( !KU( ~new_rk ) @ #vk )
                next
                  case case_2
                  by contradiction
                next
                  case case_3
                  by contradiction
                qed
              qed
            qed
          next
            case SendReceiveAsymetric_case_2
            solve( GlobalSendChainKey( ~tidB, A, B, ~new_rk, h(~new_rk)
                   ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                by solve( !KU( ~new_rk ) @ #vk )
              qed
            qed
          qed
        next
          case case_2
          solve( !KU( h(pck) ) @ #j.2 )
            case CompromiseReceiving_case_1
            solve( GlobalSendChainKey( ~tidB, A, B, ~other_rk, h(pck) ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #l )
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              next
                case case_2
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            qed
          next
            case CompromiseReceiving_case_2
            solve( GlobalSendChainKey( ~tidB, A, B, ~other_rk, h(pck) ) @ #i )
              case CompromiseSender
              by contradiction
            next
              case SendSymetric
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #l )
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              next
                case case_2
                solve( StartChainRk( ~tidB, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              qed
            qed
          next
            case CompromiseSender
            solve( (#l = #j.2)  ∥ (#j.2 < #l) )
              case case_1
              by contradiction
            next
              case case_2
              solve( (#l = #i)  ∥ (#i < #l) )
                case case_1
                by solve( GlobalSendChainKey( ~tidB, A, B, ~rk.1, h(pck) ) @ #i )
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case c_h
            solve( (#l < #i)  ∥ (#l = #i) )
              case case_1
              solve( (#j.1 = #l)  ∥ (#l < #j.1) )
                case case_1
                solve( StartChainRk( ~tidB, A, B, rk.1 ) @ #l )
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  solve( (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                    case case_1
                    by contradiction
                  next
                    case case_2
                    by contradiction
                  qed
                qed
              next
                case case_2
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case case_2
              by solve( GlobalSendChainKey( ~tidB, A, B, rk.1, h(pck) ) @ #i )
            qed
          qed
        qed
      qed
    next
      case SendReceiveAsymetric_case_2
      solve( Heal( tid, A.1, ~rk ) @ #l )
        case SendReceiveAsymetric_case_1
        solve( (#l < #i)  ∥ (#l = #i) )
          case case_1
          solve( (sck = h(rk.1))  ∥
                 (∃ pck #j.
                   (sck = h(pck)) ∧
                   (GlobalSendChainKey( ~tidA, A, B, rk.1, pck ) @ #j)
                  ∧
                   #j < #i) )
            case case_1
            solve( StartChainRk( ~tidA, A, B, rk.1 ) @ #j )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_SendToReceive
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( !KU( h(~new_rk) ) @ #j.1 )
                case CompromiseReceiving
                by contradiction
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                by solve( !KU( ~new_rk ) @ #vk )
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (#j = #l)  ∥ (#l < #j) )
                case case_1
                by contradiction
              next
                case case_2
                solve( !KU( h(~new_rk) ) @ #j.1 )
                  case CompromiseReceiving
                  by contradiction
                next
                  case CompromiseSender
                  by contradiction
                next
                  case c_h
                  solve( GlobalSendChainKey( ~tidA.1, A, B, ~new_rk, h(~new_rk)
                         ) @ #i )
                    case CompromiseSender
                    by contradiction
                  next
                    case SendSymetric
                    solve( (∃ #k.
                             (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                           (∃ #k.
                             (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                      case case_1
                      by contradiction
                    next
                      case case_2
                      by contradiction
                    qed
                  qed
                qed
              qed
            qed
          next
            case case_2
            solve( (#j = #l)  ∥ (#l < #j) )
              case case_1
              solve( StartChainRk( ~tidA, A, B, rk.1 ) @ #j )
                case SendReceiveAsymetric_case_1
                solve( !KU( h(pck) ) @ #j.2 )
                  case CompromiseReceiving_case_1
                  by contradiction
                next
                  case CompromiseReceiving_case_2
                  by contradiction
                next
                  case CompromiseSender
                  by contradiction
                next
                  case c_h
                  solve( (∃ #k.
                           (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k))  ∥
                         (∃ #k.
                           (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#j < #k)) )
                    case case_1
                    by contradiction
                  next
                    case case_2
                    by contradiction
                  qed
                qed
              next
                case SendReceiveAsymetric_case_2
                by contradiction
              qed
            next
              case case_2
              solve( !KU( h(pck) ) @ #j.2 )
                case CompromiseReceiving_case_1
                solve( StartChainRk( ~tidA, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              next
                case CompromiseReceiving_case_2
                solve( StartChainRk( ~tidA, A, B, ~other_rk ) @ #j.1 )
                  case InitKeyExchange_case_1
                  by contradiction
                next
                  case InitKeyExchange_case_2
                  by contradiction
                next
                  case SendReceiveAsymetric_ReceiveToSend
                  by contradiction
                next
                  case SendReceiveAsymetric_SendToReceive
                  by contradiction
                next
                  case SendReceiveAsymetric_case_1
                  by contradiction
                next
                  case SendReceiveAsymetric_case_2
                  by contradiction
                qed
              next
                case CompromiseSender
                by contradiction
              next
                case c_h
                solve( (∃ #k.
                         (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                       (∃ #k.
                         (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                  case case_1
                  by contradiction
                next
                  case case_2
                  by contradiction
                qed
              qed
            qed
          qed
        next
          case case_2
          by solve( GlobalSendChainKey( ~tidA, A, B, rk.1, sck ) @ #i )
        qed
      next
        case SendReceiveAsymetric_case_2
        by contradiction
      qed
    qed
  next
    case case_3
    solve( (sck = h(rk))  ∥
           (∃ pck #j.
             (sck = h(pck)) ∧ (ReceiverChain( tid, A, B, rk, pck ) @ #j)
            ∧
             #j < #i) )
      case case_1
      solve( ReceiverChain( tid, A, B, rk, h(rk) ) @ #i )
        case ReceiveSymetric
        solve( (#l < #r)  ∥ (#l = #r) )
          case case_1
          solve( !KU( h(~rk) ) @ #j )
            case CompromiseReceiving_case_1
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_2
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_3
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_4
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_5
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_6
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            qed
          next
            case CompromiseSender
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend
              by contradiction
            next
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            next
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case c_h
            solve( (∃ #k.
                     (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                   (∃ #k.
                     (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
              case case_1
              by contradiction
            next
              case case_2
              by contradiction
            qed
          qed
        next
          case case_2
          solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            solve( !KU( h(~rk) ) @ #j )
              case CompromiseReceiving_case_1
              by contradiction
            next
              case CompromiseReceiving_case_2
              by contradiction
            next
              case CompromiseReceiving_case_3
              by contradiction
            next
              case CompromiseReceiving_case_4
              by contradiction
            next
              case CompromiseSender
              by contradiction
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            solve( !KU( h(~rk) ) @ #j )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              by contradiction
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_case_1
            solve( !KU( h(~rk) ) @ #j )
              case CompromiseReceiving
              by contradiction
            next
              case CompromiseSender
              by contradiction
            next
              case c_h
              solve( (∃ #k.
                       (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                     (∃ #k.
                       (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
                case case_1
                by contradiction
              next
                case case_2
                by contradiction
              qed
            qed
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        qed
      next
        case ReceiveSymetricSkip
        solve( (#l < #r)  ∥ (#l = #r) )
          case case_1
          solve( !KU( h(~rk) ) @ #j )
            case CompromiseReceiving_case_1
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_2
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_3
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_4
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_5
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_6
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            qed
          next
            case CompromiseSender
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend
              by contradiction
            next
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            next
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case c_h
            solve( (∃ #k.
                     (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                   (∃ #k.
                     (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
              case case_1
              by contradiction
            next
              case case_2
              by contradiction
            qed
          qed
        next
          case case_2
          solve( !KU( h(~rk) ) @ #j )
            case CompromiseReceiving_case_1
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_2
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_3
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_4
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_5
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case CompromiseReceiving_case_6
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            qed
          next
            case CompromiseSender
            solve( StartChainRk( ~tidB, A, B, ~rk ) @ #l )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend
              by contradiction
            next
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            next
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          next
            case c_h
            solve( (∃ #k.
                     (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                   (∃ #k.
                     (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
              case case_1
              by contradiction
            next
              case case_2
              by contradiction
            qed
          qed
        qed
      qed
    next
      case case_2
      solve( (#l < #r)  ∥ (#l = #r) )
        case case_1
        solve( !KU( h(pck) ) @ #j.1 )
          case CompromiseReceiving_case_1
          solve( ReceiverChain( tid, A, B, ~other_rk, pck ) @ #j.1 )
            case ReceiveSymetric
            by contradiction
          next
            case ReceiveSymetricSkip
            solve( StartChainRk( ~tidB.1, A, B, ~other_rk ) @ #r )
              case InitKeyExchange_case_1
              by contradiction
            next
              case InitKeyExchange_case_2
              by contradiction
            next
              case SendReceiveAsymetric_ReceiveToSend
              by contradiction
            next
              case SendReceiveAsymetric_SendToReceive
              by contradiction
            next
              case SendReceiveAsymetric_case_1
              by contradiction
            next
              case SendReceiveAsymetric_case_2
              by contradiction
            qed
          qed
        next
          case CompromiseReceiving_case_2
          solve( StartChainRk( tid, A, B, ~other_rk ) @ #r )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction
          next
            case SendReceiveAsymetric_case_1
            by contradiction
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        next
          case CompromiseSender
          solve( StartChainRk( tid, A, B, ~rk ) @ #r )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction
          next
            case SendReceiveAsymetric_case_1
            by contradiction
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        next
          case c_h
          solve( (∃ #k.
                   (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                 (∃ #k.
                   (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
            case case_1
            by contradiction
          next
            case case_2
            by contradiction
          qed
        qed
      next
        case case_2
        solve( !KU( h(pck) ) @ #j.1 )
          case CompromiseReceiving_case_1
          solve( StartChainRk( tid, A, B, ~other_rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction
          next
            case SendReceiveAsymetric_case_1
            by contradiction
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        next
          case CompromiseReceiving_case_2
          solve( StartChainRk( tid, A, B, ~other_rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction
          next
            case SendReceiveAsymetric_case_1
            by contradiction
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        next
          case CompromiseSender
          solve( StartChainRk( tid, A, B, ~rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction
          next
            case InitKeyExchange_case_2
            by contradiction
          next
            case SendReceiveAsymetric_ReceiveToSend
            by contradiction
          next
            case SendReceiveAsymetric_SendToReceive
            by contradiction
          next
            case SendReceiveAsymetric_case_1
            by contradiction
          next
            case SendReceiveAsymetric_case_2
            by contradiction
          qed
        next
          case c_h
          solve( (∃ #k.
                   (CompromisePartie( A, B ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k))  ∥
                 (∃ #k.
                   (CompromisePartie( B, A ) @ #k) ∧ (¬(last(#k))) ∧ (#l < #k)) )
            case case_1
            by contradiction
          next
            case case_2
            by contradiction
          qed
        qed
      qed
    qed
  qed
qed


lemma PCS[ use_induction, hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B rk rk2 tid tid2 #i #j #l. StartChainRk(tid,A, B, rk )@i & KU(rk)@j & Heal(tid2,B,rk2)@l & Heal(tid,A,rk2)@l & (l < i | #l=#i)
==> (Ex  #k. CompromisePartie(A, B)@k & l < k  )
   | (Ex #k. CompromisePartie(B, A)@k & l < k   ) 
)"
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( ((¬(#l < #i)) ∧ (¬(#l = #i)))  ∥
         (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
         (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
    case case_1
    solve( (#l < #i)  ∥ (#i < #l) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_2
    by contradiction /* from formulas */
  next
    case case_3
    by contradiction /* from formulas */
  qed
qed


// Not true in sesame anymore
/*
lemma SameTidKey[reuse, use_induction]:
"
All A B rk tid tid2 rk2 #i #j. StartChainRk(tid, A, B, rk)@i & StartChainRk(tid2, A, B, rk2) @j & i<j
==> tid= tid2
"*/

lemma SameRootKeyForTid[reuse]:
"
All A B rk tid1 tid2 #i #j. StartChainRk(tid1, A, B, rk)@i & StartChainRk(tid2, A, B, rk) @j
==> #i=#j
"
/*
guarded formula characterizing all counter-examples:
"∃ A B rk tid1 tid2 #i #j.
  (StartChainRk( tid1, A, B, rk ) @ #i) ∧
  (StartChainRk( tid2, A, B, rk ) @ #j)
 ∧
  ¬(#i = #j)"
*/
simplify
solve( StartChainRk( tid1, A, B, rk ) @ #i )
  case InitKeyExchange_case_1
  solve( StartChainRk( tid2, A, B, ~rk ) @ #j )
    case InitKeyExchange_case_1
    by contradiction /* from formulas */
  next
    case InitKeyExchange_case_2
    by contradiction /* from formulas */
  qed
next
  case InitKeyExchange_case_2
  solve( StartChainRk( tid2, A, B, ~rk ) @ #j )
    case InitKeyExchange_case_1
    by contradiction /* from formulas */
  next
    case InitKeyExchange_case_2
    by contradiction /* from formulas */
  qed
next
  case SendReceiveAsymetric_ReceiveToSend
  solve( StartChainRk( tid2, A, B, ~new_rk ) @ #j )
    case SendReceiveAsymetric_ReceiveToSend
    by contradiction /* from formulas */
  qed
next
  case SendReceiveAsymetric_SendToReceive
  solve( StartChainRk( tid2, A, B, ~new_rk ) @ #j )
    case SendReceiveAsymetric_SendToReceive
    by contradiction /* from formulas */
  qed
next
  case SendReceiveAsymetric_case_1
  solve( StartChainRk( tid2, A, B, ~new_rk ) @ #j )
    case SendReceiveAsymetric_case_1
    by contradiction /* from formulas */
  next
    case SendReceiveAsymetric_case_2
    by contradiction /* from formulas */
  qed
next
  case SendReceiveAsymetric_case_2
  solve( StartChainRk( tid2, A, B, ~new_rk ) @ #j )
    case SendReceiveAsymetric_case_1
    by contradiction /* from formulas */
  next
    case SendReceiveAsymetric_case_2
    by contradiction /* from formulas */
  qed
qed

lemma StartPrev[reuse,use_induction, hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B rk tid #i . StartChainRk(tid,A, B, rk )@i
==>   (Ex #j rk2.  StartChainRk(tid,A, B, rk2 )@j & j <i)
|  InitKeyExchange(A, B) @i
)
"
/*
guarded formula characterizing all counter-examples:
"∃ A B rk tid #i.
  (StartChainRk( tid, A, B, rk ) @ #i)
 ∧
  (∀ #j rk2. (StartChainRk( tid, A, B, rk2 ) @ #j) ⇒ ¬(#j < #i)) ∧
  (¬(InitKeyExchange( A, B ) @ #i))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( StartChainRk( tid, A, B, rk ) @ #i )
    case InitKeyExchange_case_1
    by contradiction /* from formulas */
  next
    case InitKeyExchange_case_2
    by contradiction /* from formulas */
  next
    case SendReceiveAsymetric_ReceiveToSend
    solve( !ReceivingChainKey( ~tidB, ~rk, A, B, rck ) ▶₁ #i )
      case InitKeyExchange_case_1
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_2
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_3
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_4
      by contradiction /* from formulas */
    next
      case ReceiveSymetric
      by contradiction /* from formulas */
    next
      case ReceiveSymetricSkip
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_SendToReceive
      by contradiction /* from formulas */
    qed
  next
    case SendReceiveAsymetric_SendToReceive
    solve( SendingChainKey( ~rk, ~tidA, A, B, sck ) ▶₀ #i )
      case CompromiseSender
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_1
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_2
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_3
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_4
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_1
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_2
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_3
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_4
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_5
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_6
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_7
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_8
      by contradiction /* from formulas */
    next
      case SendSymetric
      by contradiction /* from formulas */
    qed
  next
    case SendReceiveAsymetric_case_1
    solve( SendingChainKey( ~rk, ~tidA, A, B, ck ) ▶₀ #i )
      case CompromiseSender
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_1
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_2
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_3
      by contradiction /* from formulas */
    next
      case InitKeyExchange_case_4
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_1
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_2
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_3
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_4
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_5
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_6
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_7
      by contradiction /* from formulas */
    next
      case SendReceiveAsymetric_ReceiveToSend_case_8
      by contradiction /* from formulas */
    next
      case SendSymetric
      by contradiction /* from formulas */
    qed
  next
    case SendReceiveAsymetric_case_2
    solve( SendingChainKey( ~rk, ~tidA, B, A, ck ) ▶₀ #i )
      case CompromiseSender
      solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(sck) ) ▶₁ #i )
        case InitKeyExchange_case_1
        by contradiction /* from formulas */
      next
        case InitKeyExchange_case_2
        by contradiction /* from formulas */
      next
        case InitKeyExchange_case_3
        by contradiction /* from formulas */
      next
        case InitKeyExchange_case_4
        by contradiction /* from formulas */
      next
        case ReceiveSymetric
        by contradiction /* from formulas */
      next
        case ReceiveSymetricSkip
        by contradiction /* from formulas */
      next
        case SendReceiveAsymetric
        by contradiction /* from formulas */
      next
        case SendReceiveAsymetric_SendToReceive
        by contradiction /* from formulas */
      qed
    next
      case InitKeyExchange_case_1
      solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk) ) ▶₁ #i )
        case InitKeyExchange
        by contradiction /* from formulas */
      qed
    next
      case InitKeyExchange_case_2
      solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk) ) ▶₁ #i )
        case InitKeyExchange
        by contradiction /* from formulas */
      qed
    next
      case InitKeyExchange_case_3
      solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk) ) ▶₁ #i )
        case InitKeyExchange
        by contradiction /* from formulas */
      qed
    next
      case InitKeyExchange_case_4
      solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk) ) ▶₁ #i )
        case InitKeyExchange
        by contradiction /* from formulas */
      qed
    next
      case SendReceiveAsymetric
      solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(~rk) ) ▶₁ #i )
        case SendReceiveAsymetric
        by contradiction /* from formulas */
      qed
    next
      case SendReceiveAsymetric_ReceiveToSend_case_1
      by solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk)
                ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_2
      by solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk)
                ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_3
      by solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk)
                ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_4
      by solve( !ReceivingChainKey( ~tidB, ~rk, $id.1, $id, h(~rk)
                ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_5
      by solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(~rk) ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_6
      by solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(~rk) ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_7
      by solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(~rk) ) ▶₁ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend_case_8
      by solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(~rk) ) ▶₁ #i )
    next
      case SendSymetric
      solve( !ReceivingChainKey( ~tidB, ~rk, A, B, h(sck) ) ▶₁ #i )
        case ReceiveSymetric
        by contradiction /* from formulas */
      next
        case ReceiveSymetricSkip
        by contradiction /* from formulas */
      qed
    qed
  qed
qed


lemma distinct_tid[reuse,use_induction, hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B rk rk2 tid tid2 tid3 #i #l. StartChainRk(tid,A, B, rk )@i & Heal(tid2,B,rk2)@l & Heal(tid3,A,rk2)@l 
==>
( tid3 = tid
 | ( Ex #j rk2.  Heal(tid,A, rk2)@j  & (j<i | #i=#j ) & l < j)
 )
 | i < l)
 "
 induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( (#i = #l)  ∥ (#l < #i) )
    case case_1
    solve( StartChainRk( tid, A, B, rk ) @ #i )
      case InitKeyExchange_case_1
      solve( Heal( tid2, B, rk2 ) @ #i )
        case InitKeyExchange_case_1
        by contradiction
      next
        case InitKeyExchange_case_2
        solve( Heal( tid3, A, ~rk ) @ #i )
          case InitKeyExchange_case_1
          by contradiction
        next
          case InitKeyExchange_case_2
          by contradiction
        qed
      qed
    next
      case InitKeyExchange_case_2
      solve( Heal( tid2, B, rk2 ) @ #i )
        case InitKeyExchange_case_1
        solve( Heal( tid3, A, ~rk ) @ #i )
          case InitKeyExchange_case_1
          by contradiction
        next
          case InitKeyExchange_case_2
          by contradiction
        qed
      next
        case InitKeyExchange_case_2
        by contradiction
      qed
    next
      case SendReceiveAsymetric_ReceiveToSend
      by solve( Heal( tid2, B, rk2 ) @ #i )
    next
      case SendReceiveAsymetric_SendToReceive
      by solve( Heal( tid2, B, rk2 ) @ #i )
    next
      case SendReceiveAsymetric_case_1
      solve( Heal( tid2, B, rk2 ) @ #i )
        case SendReceiveAsymetric_case_1
        by contradiction
      next
        case SendReceiveAsymetric_case_2
        solve( Heal( tid3, A, ~rk ) @ #i )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      qed
    next
      case SendReceiveAsymetric_case_2
      solve( Heal( tid2, B, rk2 ) @ #i )
        case SendReceiveAsymetric_case_1
        solve( Heal( tid3, A, ~rk ) @ #i )
          case SendReceiveAsymetric_case_1
          by contradiction
        next
          case SendReceiveAsymetric_case_2
          by contradiction
        qed
      next
        case SendReceiveAsymetric_case_2
        by contradiction
      qed
    qed
  next
    case case_2
    solve( (∃ #j rk2.
             (StartChainRk( tid, A, B, rk2 ) @ #j) ∧ #j < #i)  ∥
           (InitKeyExchange( A, B ) @ #i) )
      case case_1
      solve( (tid3 = tid)  ∥
             (∃ #j.1 rk2.
               (Heal( tid, A, rk2 ) @ #j.1)
              ∧
               (¬(last(#j.1))) ∧ (((#j.1 < #j) ∨ (#j = #j.1))) ∧ (#l < #j.1))  ∥
             (#j < #l) )
        case case_1
        by contradiction
      next
        case case_2
        solve( (#j.1 = #i)  ∥ (#i < #j.1) )
          case case_1
          by contradiction
        next
          case case_2
          by contradiction
        qed
      next
        case case_3
        solve( Heal( tid3, A, rk2.1 ) @ #l )
          case InitKeyExchange_case_1
          solve( Heal( tid2, B.1, ~rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction /* from formulas */
          next
            case InitKeyExchange_case_2
            by contradiction /* from formulas */
          qed
        next
          case InitKeyExchange_case_2
          solve( Heal( tid2, B, ~rk ) @ #l )
            case InitKeyExchange_case_1
            by contradiction /* from formulas */
          next
            case InitKeyExchange_case_2
            by contradiction /* from formulas */
          qed
        next
          case SendReceiveAsymetric_case_1
          solve( Heal( tid2, B.1, ~rk ) @ #l )
            case SendReceiveAsymetric_case_1
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric_case_2
            by contradiction /* from formulas */
          qed
        next
          case SendReceiveAsymetric_case_2
          solve( Heal( tid2, B, ~rk ) @ #l )
            case SendReceiveAsymetric_case_1
            by contradiction /* from formulas */
          next
            case SendReceiveAsymetric_case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case case_2
      solve( InitKeyExchange( A, B ) @ #i )
        case InitKeyExchange_case_1
        solve( StartChainRk( tid, A, B, rk.1 ) @ #i )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      next
        case InitKeyExchange_case_2
        solve( StartChainRk( tid, A, B, rk.1 ) @ #i )
          case InitKeyExchange_case_1
          by contradiction /* from formulas */
        next
          case InitKeyExchange_case_2
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed



lemma SamePartner[reuse,use_induction, hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B B2 rk rk2 tid #i #j . StartChainRk(tid,A, B, rk )@i & StartChainRk(tid,A, B2, rk2 )@j
==> B=B2)
"


lemma PCS_Conversation[ hide_lemma=ForwardSecrecySender, hide_lemma=AsymmetricNeedsCompromiseBefore]:
"
(All A B rk rk2 #i #j #l. ConversationStartChainRk(A, B, rk )@i & KU(rk)@j & ConversationHeal(A,B,rk2)@l & ConversationHeal(A, B, rk2)@l & (l < i | #l=#i)
==> (Ex  #k. CompromisePartie(A, B)@k & l < k  )
   | (Ex #k. CompromisePartie(B, A)@k & l < k   ) 
)"
/*
guarded formula characterizing all counter-examples:
"∃ A B rk rk2 #i #j #l.
  (ConversationStartChainRk( A, B, rk ) @ #i) ∧
  (!KU( rk ) @ #j) ∧
  (ConversationHeal( A, B, rk2 ) @ #l) ∧
  (ConversationHeal( A, B, rk2 ) @ #l)
 ∧
  (((#l < #i) ∨ (#l = #i))) ∧
  (∀ #k. (CompromisePartie( A, B ) @ #k) ⇒ ¬(#l < #k)) ∧
  (∀ #k. (CompromisePartie( B, A ) @ #k) ⇒ ¬(#l < #k))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (#l < #i)  ∥ (#l = #i) )
    case case_1
    solve( ConversationStartChainRk( A, B, rk ) @ #i )
      case InitKeyExchange_case_1
      by solve( !KU( ~rk ) @ #j )
    next
      case InitKeyExchange_case_2
      by solve( !KU( ~rk ) @ #j )
    next
      case SendReceiveAsymetric_ReceiveToSend
      solve( ConversationHeal( A, B, rk2 ) @ #l )
        case SendReceiveAsymetric_case_1
        solve( (~tidA = ~tidB)  ∥
               (∃ #j.1 rk2.
                 (Heal( ~tidB, A, rk2 ) @ #j.1)
                ∧
                 (((#j.1 < #j) ∨ (#j = #j.1))) ∧ (#l < #j.1))  ∥
               (#j < #l) )
          case case_1
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          solve( (#j.1 < #j)  ∥ (#j = #j.1) )
            case case_1
            solve( Heal( ~tidB, A, rk2.1 ) @ #j.1 )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            solve( Heal( ~tidB, A, rk2 ) @ #j )
              case InitKeyExchange_case_1
              solve( StartChainRk( ~tidB, A, B, rk2 ) @ #j )
                case InitKeyExchange
                solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                       (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_3
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( (~tidB.1 = ~tidB)  ∥
               (∃ #j rk2.
                 (Heal( ~tidB, A, rk2 ) @ #j)
                ∧
                 (((#j < #i) ∨ (#i = #j))) ∧ (#l < #j)) )
          case case_1
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          solve( (#j.1 < #i)  ∥ (#i = #j.1) )
            case case_1
            solve( Heal( ~tidB, A, rk2.1 ) @ #j.1 )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            by solve( Heal( ~tidB, A, rk2 ) @ #i )
          qed
        qed
      qed
    next
      case SendReceiveAsymetric_SendToReceive
      solve( ConversationHeal( A, B, rk2 ) @ #l )
        case SendReceiveAsymetric_case_1
        solve( (~tidA.1 = ~tidA)  ∥
               (∃ #j.1 rk2.
                 (Heal( ~tidA, A, rk2 ) @ #j.1)
                ∧
                 (((#j.1 < #j) ∨ (#j = #j.1))) ∧ (#l < #j.1))  ∥
               (#j < #l) )
          case case_1
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          solve( (#j.1 < #j)  ∥ (#j = #j.1) )
            case case_1
            solve( Heal( ~tidA, A, rk2.1 ) @ #j.1 )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            solve( Heal( ~tidA, A, rk2 ) @ #j )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_3
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SendReceiveAsymetric_case_2
        solve( (~tidB = ~tidA)  ∥
               (∃ #j.1 rk2.
                 (Heal( ~tidA, A, rk2 ) @ #j.1)
                ∧
                 (((#j.1 < #j) ∨ (#j = #j.1))) ∧ (#l < #j.1))  ∥
               (#j < #l) )
          case case_1
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          solve( (#j.1 < #j)  ∥ (#j = #j.1) )
            case case_1
            solve( Heal( ~tidA, A, rk2.1 ) @ #j.1 )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case case_2
            solve( Heal( ~tidA, A, rk2 ) @ #j )
              case InitKeyExchange_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case InitKeyExchange_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_1
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case SendReceiveAsymetric_case_2
              solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #j < #k)  ∥
                     (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #j < #k) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case case_3
          solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #l < #k)  ∥
                 (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #l < #k) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    next
      case SendReceiveAsymetric_case_1
      solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #i < #k)  ∥
             (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #i < #k) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case SendReceiveAsymetric_case_2
      solve( (∃ #k. (CompromisePartie( A, B ) @ #k) ∧ #i < #k)  ∥
             (∃ #k. (CompromisePartie( B, A ) @ #k) ∧ #i < #k) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    solve( ConversationStartChainRk( A, B, rk ) @ #i )
      case InitKeyExchange_case_1
      by solve( ConversationHeal( A, B, rk2 ) @ #i )
    next
      case InitKeyExchange_case_2
      by solve( ConversationHeal( A, B, rk2 ) @ #i )
    next
      case SendReceiveAsymetric_ReceiveToSend
      by solve( ConversationHeal( A, B, rk2 ) @ #i )
    next
      case SendReceiveAsymetric_SendToReceive
      by solve( ConversationHeal( A, B, rk2 ) @ #i )
    next
      case SendReceiveAsymetric_case_1
      solve( ConversationHeal( A, B, rk2 ) @ #i )
        case SendReceiveAsymetric_case_1
        by solve( !KU( ~new_rk ) @ #j.2 )
      next
        case SendReceiveAsymetric_case_2
        by contradiction /* from formulas */
      qed
    next
      case SendReceiveAsymetric_case_2
      by solve( !KU( ~new_rk ) @ #j.2 )
    qed
  qed
qed



end
